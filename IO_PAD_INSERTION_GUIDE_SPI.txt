#==============================================================================
# IO PAD INSERTION GUIDE - Lab 3 Assignment
# Adding IO Area to Floorplan for SPI Master Controller
#==============================================================================

OVERVIEW:
=========
To add IO area to the floorplan, you need to:
1. Select appropriate IO pad cells from the library
2. Create an IO placement file (.io file)
3. Modify the floorplan to include IO boundary spacing
4. Place IO pads in a pad ring around the core
5. Connect IO pads to internal signals

STEP-BY-STEP PROCESS:
=====================

STEP 1: Identify Available IO Pad Cells
----------------------------------------
From gsclib045 library, typical IO pad types include:

a) Signal Pads:
   - PADCELL_SIG_H     : Digital input/output pad
   - INPUT_PAD         : Input only pad
   - OUTPUT_PAD        : Output only pad
   - BIDIR_PAD         : Bidirectional pad

b) Power Pads:
   - PADCELL_VDD       : VDD power pad
   - PADCELL_GND       : Ground pad
   - PADCELL_VDDIO     : IO voltage pad
   - PADCELL_GNDIO     : IO ground pad

c) Corner Pads:
   - PADCELL_CORNER    : Corner cell for pad ring
   - CORNER_LL         : Lower left corner
   - CORNER_LR         : Lower right corner
   - CORNER_UL         : Upper left corner
   - CORNER_UR         : Upper right corner

d) Special Pads:
   - PADCELL_FILLER    : Filler cells for pad ring continuity

Note: Check your library's LEF files for exact pad cell names:
      ../input/libs/gsclib045/lef/gsclib045_macro.lef


STEP 2: Create Top-Level Wrapper with IO Pads (SPI Master)
-----------------------------------------------------------
You need to wrap your core design with IO pads. Create a new top-level module:

File: spi_master_with_pads.v

module spi_master_chip (
    // External IO pins (connected to pads)
    inout wire PAD_VDD,
    inout wire PAD_GND,
    inout wire PAD_VDDIO,
    inout wire PAD_GNDIO,

    // System signals
    inout wire PAD_clk,
    inout wire PAD_reset,

    // Control signals
    inout wire PAD_start,
    inout wire PAD_cpol,
    inout wire PAD_cpha,
    inout wire PAD_clk_div_0,
    inout wire PAD_clk_div_1,

    // Data interface
    inout wire PAD_tx_data_0,
    inout wire PAD_tx_data_1,
    inout wire PAD_tx_data_2,
    inout wire PAD_tx_data_3,
    inout wire PAD_tx_data_4,
    inout wire PAD_tx_data_5,
    inout wire PAD_tx_data_6,
    inout wire PAD_tx_data_7,

    inout wire PAD_rx_data_0,
    inout wire PAD_rx_data_1,
    inout wire PAD_rx_data_2,
    inout wire PAD_rx_data_3,
    inout wire PAD_rx_data_4,
    inout wire PAD_rx_data_5,
    inout wire PAD_rx_data_6,
    inout wire PAD_rx_data_7,

    inout wire PAD_rx_valid,
    inout wire PAD_busy,

    // SPI interface
    inout wire PAD_sclk,
    inout wire PAD_mosi,
    inout wire PAD_miso,
    inout wire PAD_ss_n,

    // DFT signals
    inout wire PAD_SE,
    inout wire PAD_scan_in,
    inout wire PAD_scan_out
);

    // Internal signals (core side)
    wire clk_core, reset_core;
    wire start_core, cpol_core, cpha_core;
    wire [1:0] clk_div_core;
    wire [7:0] tx_data_core, rx_data_core;
    wire rx_valid_core, busy_core;
    wire sclk_core, mosi_core, miso_core, ss_n_core;
    wire SE_core, scan_in_core, scan_out_core;

    // Instantiate corner pads
    PADCELL_CORNER corner_ll ();
    PADCELL_CORNER corner_lr ();
    PADCELL_CORNER corner_ul ();
    PADCELL_CORNER corner_ur ();

    // Instantiate power pads (multiple for current distribution)
    PADCELL_VDD vdd_pad0 (.PAD(PAD_VDD), .COREIO(VDD));
    PADCELL_VDD vdd_pad1 (.PAD(PAD_VDD), .COREIO(VDD));
    PADCELL_GND gnd_pad0 (.PAD(PAD_GND), .COREIO(GND));
    PADCELL_GND gnd_pad1 (.PAD(PAD_GND), .COREIO(GND));

    // Instantiate input pads - System
    INPUT_PAD pad_clk (.PAD(PAD_clk), .C(clk_core));
    INPUT_PAD pad_reset (.PAD(PAD_reset), .C(reset_core));

    // Instantiate input pads - Control
    INPUT_PAD pad_start (.PAD(PAD_start), .C(start_core));
    INPUT_PAD pad_cpol (.PAD(PAD_cpol), .C(cpol_core));
    INPUT_PAD pad_cpha (.PAD(PAD_cpha), .C(cpha_core));
    INPUT_PAD pad_clk_div_0 (.PAD(PAD_clk_div_0), .C(clk_div_core[0]));
    INPUT_PAD pad_clk_div_1 (.PAD(PAD_clk_div_1), .C(clk_div_core[1]));

    // Instantiate input pads - TX Data
    INPUT_PAD pad_tx_data_0 (.PAD(PAD_tx_data_0), .C(tx_data_core[0]));
    INPUT_PAD pad_tx_data_1 (.PAD(PAD_tx_data_1), .C(tx_data_core[1]));
    INPUT_PAD pad_tx_data_2 (.PAD(PAD_tx_data_2), .C(tx_data_core[2]));
    INPUT_PAD pad_tx_data_3 (.PAD(PAD_tx_data_3), .C(tx_data_core[3]));
    INPUT_PAD pad_tx_data_4 (.PAD(PAD_tx_data_4), .C(tx_data_core[4]));
    INPUT_PAD pad_tx_data_5 (.PAD(PAD_tx_data_5), .C(tx_data_core[5]));
    INPUT_PAD pad_tx_data_6 (.PAD(PAD_tx_data_6), .C(tx_data_core[6]));
    INPUT_PAD pad_tx_data_7 (.PAD(PAD_tx_data_7), .C(tx_data_core[7]));

    // Instantiate input pads - SPI MISO
    INPUT_PAD pad_miso (.PAD(PAD_miso), .C(miso_core));

    // Instantiate input pads - DFT
    INPUT_PAD pad_SE (.PAD(PAD_SE), .C(SE_core));
    INPUT_PAD pad_scan_in (.PAD(PAD_scan_in), .C(scan_in_core));

    // Instantiate output pads - RX Data
    OUTPUT_PAD pad_rx_data_0 (.I(rx_data_core[0]), .PAD(PAD_rx_data_0));
    OUTPUT_PAD pad_rx_data_1 (.I(rx_data_core[1]), .PAD(PAD_rx_data_1));
    OUTPUT_PAD pad_rx_data_2 (.I(rx_data_core[2]), .PAD(PAD_rx_data_2));
    OUTPUT_PAD pad_rx_data_3 (.I(rx_data_core[3]), .PAD(PAD_rx_data_3));
    OUTPUT_PAD pad_rx_data_4 (.I(rx_data_core[4]), .PAD(PAD_rx_data_4));
    OUTPUT_PAD pad_rx_data_5 (.I(rx_data_core[5]), .PAD(PAD_rx_data_5));
    OUTPUT_PAD pad_rx_data_6 (.I(rx_data_core[6]), .PAD(PAD_rx_data_6));
    OUTPUT_PAD pad_rx_data_7 (.I(rx_data_core[7]), .PAD(PAD_rx_data_7));

    // Instantiate output pads - Status
    OUTPUT_PAD pad_rx_valid (.I(rx_valid_core), .PAD(PAD_rx_valid));
    OUTPUT_PAD pad_busy (.I(busy_core), .PAD(PAD_busy));

    // Instantiate output pads - SPI
    OUTPUT_PAD pad_sclk (.I(sclk_core), .PAD(PAD_sclk));
    OUTPUT_PAD pad_mosi (.I(mosi_core), .PAD(PAD_mosi));
    OUTPUT_PAD pad_ss_n (.I(ss_n_core), .PAD(PAD_ss_n));

    // Instantiate output pads - DFT
    OUTPUT_PAD pad_scan_out (.I(scan_out_core), .PAD(PAD_scan_out));

    // Instantiate the SPI Master core
    spi_master spi_core (
        .clk(clk_core),
        .reset(reset_core),
        .start(start_core),
        .cpol(cpol_core),
        .cpha(cpha_core),
        .clk_div(clk_div_core),
        .tx_data(tx_data_core),
        .rx_data(rx_data_core),
        .rx_valid(rx_valid_core),
        .busy(busy_core),
        .sclk(sclk_core),
        .mosi(mosi_core),
        .miso(miso_core),
        .ss_n(ss_n_core)
        // Note: DFT ports added during DFT insertion
    );

endmodule


STEP 3: Create IO Placement File (SPI Master)
----------------------------------------------
Create an .io file to specify pad locations around the chip perimeter.

File: spi_master.io

(globals
    version = 3
    io_order = default
)

(iopad
    # Corner pads
    (topleft
        (inst name="corner_ul" offset=0)
    )

    (topright
        (inst name="corner_ur" offset=0)
    )

    (bottomleft
        (inst name="corner_ll" offset=0)
    )

    (bottomright
        (inst name="corner_lr" offset=0)
    )

    # Left side pads (bottom to top)
    (left
        (inst name="gnd_pad0" offset=100)
        (inst name="pad_clk" offset=200)
        (inst name="pad_reset" offset=300)
        (inst name="pad_start" offset=400)
        (inst name="pad_cpol" offset=500)
        (inst name="pad_cpha" offset=600)
        (inst name="pad_clk_div_0" offset=700)
        (inst name="pad_clk_div_1" offset=800)
        (inst name="pad_tx_data_0" offset=900)
    )

    # Bottom side pads (left to right)
    (bottom
        (inst name="pad_tx_data_1" offset=100)
        (inst name="pad_tx_data_2" offset=200)
        (inst name="pad_tx_data_3" offset=300)
        (inst name="pad_tx_data_4" offset=400)
        (inst name="pad_tx_data_5" offset=500)
        (inst name="pad_tx_data_6" offset=600)
        (inst name="pad_tx_data_7" offset=700)
        (inst name="pad_miso" offset=800)
        (inst name="pad_SE" offset=900)
    )

    # Right side pads (bottom to top)
    (right
        (inst name="pad_scan_in" offset=100)
        (inst name="pad_rx_data_0" offset=200)
        (inst name="pad_rx_data_1" offset=300)
        (inst name="pad_rx_data_2" offset=400)
        (inst name="pad_rx_data_3" offset=500)
        (inst name="pad_rx_data_4" offset=600)
        (inst name="pad_rx_data_5" offset=700)
        (inst name="pad_rx_data_6" offset=800)
        (inst name="pad_rx_data_7" offset=900)
    )

    # Top side pads (left to right)
    (top
        (inst name="pad_rx_valid" offset=100)
        (inst name="pad_busy" offset=200)
        (inst name="pad_sclk" offset=300)
        (inst name="pad_mosi" offset=400)
        (inst name="pad_ss_n" offset=500)
        (inst name="pad_scan_out" offset=600)
        (inst name="vdd_pad0" offset=800)
        (inst name="vdd_pad1" offset=1000)
        (inst name="gnd_pad1" offset=1200)
    )
)


STEP 4: Modified Floorplan Commands in Innovus (SPI Master)
------------------------------------------------------------

# After importing design and before floorplan specification:

# 1. Load IO placement file
innovus> loadIoFile spi_master.io

# 2. Specify floorplan WITH IO AREA
innovus> floorPlan \
    -r 1.0 \
    -coreMargin 150 150 150 150 \
    -coreMarginsBy io

# Key parameters:
# -coreMargin: Distance from core to IO boundary (must accommodate pad width)
# -coreMarginsBy io: Specify margins are from IO boundary, not die boundary

# 3. Place IO pads
innovus> commitIoPlacement

# 4. Check pad placement
innovus> checkPlace -ioPlacement

For detailed commands, see the modified Place & Route script.
